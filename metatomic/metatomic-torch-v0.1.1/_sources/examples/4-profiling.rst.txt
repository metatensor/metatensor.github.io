
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/4-profiling.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_4-profiling.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_4-profiling.py:


Profiling your models
=====================

.. py:currentmodule:: metatomic.torch

Do you feel like your model is too slow? Do you want to make it faster? Instead of
guessing which part of the code is responsible for any slowdown, you should profile your
code to learn how much time is spent in each function and where to focus any
optimization efforts.

In this tutorial you'll learn how to profile your model using PyTorch profiler, how to
read the output of the profiler, and how to add your own labels for new functions/steps
in your model forward function.

.. GENERATED FROM PYTHON SOURCE LINES 16-35

.. code-block:: Python


    from typing import Dict, List, Optional

    import ase.build
    import matplotlib.pyplot as plt
    import numpy as np
    import torch
    from metatensor.torch import Labels, TensorBlock, TensorMap

    from metatomic.torch import (
        AtomisticModel,
        ModelCapabilities,
        ModelMetadata,
        ModelOutput,
        System,
    )
    from metatomic.torch.ase_calculator import MetatomicCalculator









.. GENERATED FROM PYTHON SOURCE LINES 36-39

When profiling your code, it is important to run the model on a representative system
to ensure you are actually exercising the behavior of your model at the right scale.
Here we'll use a relatively large system with many atoms.

.. GENERATED FROM PYTHON SOURCE LINES 40-46

.. code-block:: Python


    primitive = ase.build.bulk(name="C", crystalstructure="diamond", a=3.567)
    atoms = ase.build.make_supercell(primitive, 10 * np.eye(3))
    print(f"We have {len(atoms)} atoms in our system")






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    We have 2000 atoms in our system




.. GENERATED FROM PYTHON SOURCE LINES 47-55

We will use the same ``HarmonicModel`` as in the :ref:`previous tutorial
<atomistic-tutorial-md>` as our machine learning potential.

.. raw:: html

    <details>
    <summary>Click to see the definition of HarmonicModel</summary>


.. GENERATED FROM PYTHON SOURCE LINES 56-130

.. code-block:: Python



    class HarmonicModel(torch.nn.Module):
        def __init__(self, force_constant: float, equilibrium_positions: torch.Tensor):
            """Create an ``HarmonicModel``.

            :param force_constant: force constant, in ``energy unit / (length unit)^2``
            :param equilibrium_positions: torch tensor with shape ``n x 3``, containing the
                equilibrium positions of all atoms
            """
            super().__init__()
            assert force_constant > 0
            self.force_constant = force_constant
            self.equilibrium_positions = equilibrium_positions

        def forward(
            self,
            systems: List[System],
            outputs: Dict[str, ModelOutput],
            selected_atoms: Optional[Labels],
        ) -> Dict[str, TensorMap]:
            if list(outputs.keys()) != ["energy"]:
                raise ValueError(
                    "this model can only compute 'energy', but `outputs` contains other "
                    f"keys: {', '.join(outputs.keys())}"
                )

            # we don't want to worry about selected_atoms yet
            if selected_atoms is not None:
                raise NotImplementedError("selected_atoms is not implemented")

            if outputs["energy"].per_atom:
                raise NotImplementedError("per atom energy is not implemented")

            # compute the energy for each system by adding together the energy for each atom
            energy = torch.zeros((len(systems), 1), dtype=systems[0].positions.dtype)
            for i, system in enumerate(systems):
                assert len(system) == self.equilibrium_positions.shape[0]
                r0 = self.equilibrium_positions
                energy[i] += torch.sum(self.force_constant * (system.positions - r0) ** 2)

            # add metadata to the output
            block = TensorBlock(
                values=energy,
                samples=Labels("system", torch.arange(len(systems)).reshape(-1, 1)),
                components=[],
                properties=Labels("energy", torch.tensor([[0]])),
            )
            return {
                "energy": TensorMap(keys=Labels("_", torch.tensor([[0]])), blocks=[block])
            }


    model = HarmonicModel(
        force_constant=3.14159265358979323846,
        equilibrium_positions=torch.tensor(atoms.positions),
    )

    capabilities = ModelCapabilities(
        outputs={
            "energy": ModelOutput(quantity="energy", unit="eV", per_atom=False),
        },
        atomic_types=[6],
        interaction_range=0.0,
        length_unit="Angstrom",
        supported_devices=["cpu"],
        dtype="float32",
    )

    metadata = ModelMetadata()
    wrapper = AtomisticModel(model.eval(), metadata, capabilities)

    wrapper.export("exported-model.pt")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /home/runner/work/metatomic/metatomic/python/examples/4-profiling.py:128: DeprecationWarning: `export()` is deprecated, use `save()` instead
      wrapper.export("exported-model.pt")




.. GENERATED FROM PYTHON SOURCE LINES 131-135

.. raw:: html

    </details>


.. GENERATED FROM PYTHON SOURCE LINES 139-141

If you are trying to profile your own model, you can start here and create a
``MetatomicCalculator`` with your own model.

.. GENERATED FROM PYTHON SOURCE LINES 142-146

.. code-block:: Python



    atoms.calc = MetatomicCalculator("exported-model.pt")








.. GENERATED FROM PYTHON SOURCE LINES 147-149

Before trying to profile the code, it is a good idea to run it a couple of times to
allow torch to warmup internally.

.. GENERATED FROM PYTHON SOURCE LINES 150-154

.. code-block:: Python


    atoms.get_forces()
    atoms.get_potential_energy()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    np.float64(3.770593615115558e-09)



.. GENERATED FROM PYTHON SOURCE LINES 155-161

Profiling energy calculation
----------------------------

Now we can run code using :py:func:`torch.profiler.profile` to collect statistic on
how long each function takes to run. We randomize the positions to force ASE to
recompute the energy of the system

.. GENERATED FROM PYTHON SOURCE LINES 162-169

.. code-block:: Python


    atoms.positions += np.random.rand(*atoms.positions.shape)
    with torch.profiler.profile() as energy_profiler:
        atoms.get_potential_energy()

    print(energy_profiler.key_averages().table(sort_by="self_cpu_time_total", row_limit=10))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ----------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                                        Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls  
    ----------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                              Model::forward        88.70%      11.816ms        91.71%      12.216ms      12.216ms             1  
               ASECalculator::prepare_inputs         2.51%     333.754us         3.49%     465.171us     465.171us             1  
                                     forward         1.44%     191.918us         3.00%     400.299us     400.299us             1  
          AtomisticModel::check_atomic_types         0.73%      97.522us         1.51%     200.746us     200.746us             1  
        AtomisticModel::convert_units_output         0.70%      93.154us         0.73%      97.603us      97.603us             1  
                 ASECalculator::sum_energies         0.57%      75.341us         0.57%      75.341us      75.341us             1  
            ASECalculator::compute_neighbors         0.46%      61.855us         0.88%     117.489us     117.489us             1  
                                  aten::isin         0.46%      61.676us         0.50%      67.236us      67.236us             1  
         AtomisticModel::convert_units_input         0.44%      59.060us         0.46%      61.705us      61.705us             1  
              ASECalculator::convert_outputs         0.39%      51.727us         0.54%      71.454us      71.454us             1  
    ----------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
    Self CPU time total: 13.321ms





.. GENERATED FROM PYTHON SOURCE LINES 170-195

There are a couple of interesting things to see here. First the total runtime of the
code is shown in the bottom; and then the most costly functions are visible on top,
one line per function. For each function, ``Self CPU`` refers to the time spent in
this function **excluding** any called functions; and ``CPU total`` refers to the time
spent in this function, **including** called functions.

For more options to record operations and display the output, please refer to the
`official documentation for PyTorch profiler
<https://pytorch.org/docs/stable/profiler.html>`_.

Here, ``Model::forward`` indicates the time taken by your model's ``forward()``.
Anything starting with ``aten::`` comes from operations on torch tensors, typically
with the same function name as the corresponding torch functions (e.g.
``aten::arange`` is :py:func:`torch.arange`). We can also see some internal functions
from metatomic, with the name staring with ``AtomisticModel::`` for
:py:class:`AtomisticModel`; and ``ASECalculator::`` for
:py:class:`ase_calculator.MetatomicCalculator`.

If you want to see more details on the internal steps taken by your model, you can add
:py:func:`torch.profiler.record_function`
(https://pytorch.org/docs/stable/generated/torch.autograd.profiler.record_function.html)
inside your model code to give names to different steps in the calculation. This is
how we are internally adding names such as ``Model::forward`` or
``ASECalculator::prepare_inputs`` above.


.. GENERATED FROM PYTHON SOURCE LINES 198-203

Profiling forces calculation
----------------------------

Let's now do the same, but computing the forces for this system. This mean we should
now see some time spent in the ``backward()`` function, on top of everything else.

.. GENERATED FROM PYTHON SOURCE LINES 204-212

.. code-block:: Python


    atoms.positions += np.random.rand(*atoms.positions.shape)
    with torch.profiler.profile() as forces_profiler:
        atoms.get_forces()

    print(forces_profiler.key_averages().table(sort_by="self_cpu_time_total", row_limit=10))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    -------------------------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                                                       Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls  
    -------------------------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
    torch::jit::(anonymous namespace)::DifferentiableGra...        23.31%     784.830us        25.99%     874.919us     874.919us             1  
                                                    forward        15.91%     535.813us        21.14%     711.923us     711.923us             1  
                              ASECalculator::prepare_inputs         9.75%     328.126us        16.32%     549.589us     549.589us             1  
                             ASECalculator::convert_outputs         5.18%     174.437us         6.82%     229.691us     229.691us             1  
                                ASECalculator::run_backward         4.91%     165.360us        35.79%       1.205ms       1.205ms             1  
                                             Model::forward         4.29%     144.481us        25.44%     856.404us     856.404us             1  
                                                   aten::mm         4.04%     136.076us         4.09%     137.758us      34.440us             4  
                                                aten::copy_         2.80%      94.326us         2.80%      94.326us       4.492us            21  
                         AtomisticModel::check_atomic_types         2.70%      90.861us         5.83%     196.227us     196.227us             1  
                       AtomisticModel::convert_units_output         2.07%      69.860us         2.15%      72.525us      72.525us             1  
    -------------------------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
    Self CPU time total: 3.367ms





.. GENERATED FROM PYTHON SOURCE LINES 213-214

Let's visualize this data in an other way:

.. GENERATED FROM PYTHON SOURCE LINES 215-239

.. code-block:: Python


    events = forces_profiler.key_averages()
    events = sorted(events, key=lambda u: u.self_cpu_time_total, reverse=True)
    total_cpu_time = sum(map(lambda u: u.self_cpu_time_total, events))

    bottom = 0.0
    for event in events:
        self_time = event.self_cpu_time_total
        name = event.key
        if len(name) > 30:
            name = name[:12] + "[...]" + name[-12:]

        if self_time > 0.03 * total_cpu_time:
            plt.bar(0, self_time, bottom=bottom, label=name)
            bottom += self_time
        else:
            plt.bar(0, total_cpu_time - bottom, bottom=bottom, label="others")
            break

    plt.legend()
    plt.xticks([])
    plt.xlim(0, 1)
    plt.ylabel("self time / µs")
    plt.show()



.. image-sg:: /examples/images/sphx_glr_4-profiling_001.png
   :alt: 4 profiling
   :srcset: /examples/images/sphx_glr_4-profiling_001.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.193 seconds)


.. _sphx_glr_download_examples_4-profiling.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 4-profiling.ipynb <4-profiling.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 4-profiling.py <4-profiling.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: 4-profiling.zip <4-profiling.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
